<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0">
  <id>https://dottedmag.net/</id>
  <title>Mikhail Gusarov</title>
  
  <updated>2023-07-08T00:00:00Z</updated>
  
  <author><name>Mikhail Gusarov</name></author>
  <link href="https://dottedmag.net/" rel="alternate"></link>
  <link href="https://dottedmag.net/blog.atom" rel="self"></link>



<entry>
  <id>https://dottedmag.net/blog/principle-codenames/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">Codenames</title>
  <published>2023-07-08T00:00:00Z</published>
  <updated>2023-07-08T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/principle-codenames/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;Codenames are useful.&lt;/p&gt;
&lt;p&gt;Whenever we develop software we invent names. Tons of names. VCS repository
names, directory names, executable names, package names, class names, function
names, configuration file names, database names, usernames. The list goes on.&lt;/p&gt;
&lt;p&gt;A natural impulse is to use your product&amp;rsquo;s name in these names. After all,
if you are developing X it makes sense to name things after X.&lt;/p&gt;
&lt;p&gt;The problem is that most of the time we don&amp;rsquo;t know how the project will turn
out: the product might (and probably will) change its the target audience,
format and may metamorphose completely.&lt;/p&gt;
&lt;p&gt;You can guess what happens in this case: public-facing identifiers will
be changed quickly, but internal ones will lag: the ones that are easy to
change will be changed eventually, the ones that are hard will get stuck.&lt;/p&gt;
&lt;p&gt;Now imagine the public name changing several times over the lifetime of the
project.&lt;/p&gt;
&lt;p&gt;The codebase will accrete all names used by the product in past. From time to
time a heroic effort will be applied to clean the old cruft, as it becomes
harder and harder to explain to new team members that X, Y, Z and W are
actually the same thing. It will &lt;em&gt;mostly&lt;/em&gt; succeed, except that one place
that requires somebody to spend an hour in a SaaS console somewhere&amp;hellip; However
there is a backlog of features, so let&amp;rsquo;s postpone it to another day&amp;hellip;&lt;/p&gt;
&lt;p&gt;Changing identifiers is a huge waste of time. Use codenames instead.&lt;/p&gt;
&lt;p&gt;Codename is an internal techincal identifier. It is guarded from marketing.
It is not allowed to escape to the public. It is stable. It is used everywhere
where internal identifiers are needed, starting from the name of VCS repository.&lt;/p&gt;
&lt;p&gt;Use codenames as much as you can. Don&amp;rsquo;t leak them to the users though.&lt;/p&gt;
&lt;p&gt;P.S: If you develop desktop software, more details of your software leak
to the users: configuration files or main executables should be named
after marketing name. The life is much easier for SaaS or mobile apps:
user-facing domains, UIs, marketplace entries and APIs have to use marketing
names, everything else is hidden from the users and should use the codename.&lt;/p&gt;

  
    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/03-de-drm-ioctl/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - DRM operations (1)</title>
  <published>2023-07-08T00:00:00Z</published>
  <updated>2023-07-08T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/03-de-drm-ioctl/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;What can compositor do with DRM devices once it &lt;a href=&#34;/blog/01-de-drm/&#34;&gt;has found&lt;/a&gt; them?&lt;/p&gt;
&lt;p&gt;These devices respond to a number of &lt;code&gt;ioctl&lt;/code&gt;s. All DRM devices respond to a set
of common &lt;code&gt;ioctl&lt;/code&gt;s that cover display controller functionality, and there are
driver-specific &lt;code&gt;ioctl&lt;/code&gt;s used chiefly by Mesa for rendering operations.&lt;/p&gt;
&lt;p&gt;The list of &lt;code&gt;ioctl&lt;/code&gt;s is pretty large, so this post covers only a small subset.&lt;/p&gt;
&lt;h2 id=&#34;versions&#34;&gt;Versions&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;DRM_IOCTL_VERSION&lt;/code&gt; returns human-readable version, name, description
and (release?) date of DRM device.&lt;/p&gt;
&lt;h2 id=&#34;device-capabilities&#34;&gt;Device capabilities&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;DRM_IOCTL_GET_CAP&lt;/code&gt; returns capabilities of a DRM device.&lt;/p&gt;
&lt;p&gt;Many of these capabilities refer to specific DRM &lt;code&gt;ioctl&lt;/code&gt;s, so they may not
make much sense yet.&lt;/p&gt;
&lt;h3 id=&#34;framebuffer-capabilities&#34;&gt;Framebuffer capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_ADDFB2_MODIFIERS&lt;/code&gt;. boolean. Framebuffers support pixel format modifiers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_DUMB_BUFFER&lt;/code&gt;. boolean. The device can create dumb framebuffers (&lt;code&gt;DRM_IOCTL_MODE_CREATE_DUMB&lt;/code&gt; et al)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_DUMB_PREFERRED_DEPTH&lt;/code&gt;. integer. The preferred pixel depth of dumb framebuffers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_DUMB_PREFER_SHADOW&lt;/code&gt;. boolean. Non-sequential writes or reading from dumb framebuffer is slow.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;syncobj-capabilities&#34;&gt;Syncobj capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_SYNCOBJ&lt;/code&gt;. boolean. The device supports DRM sync objects.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_SYNCOBJ_TIMELINE&lt;/code&gt;. boolean. The device supports DRM timeline sync objects
(they can signal at specific points in their lifetimes).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;page-flipping-capabilities&#34;&gt;Page flipping capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_ASYNC_PAGE_FLIP&lt;/code&gt;. boolean. The device can pageflip without delay (tearing pageflip).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_PAGE_FLIP_TARGET&lt;/code&gt;. boolean. The device can pageflip with a specified target
(&lt;code&gt;DRM_MODE_PAGE_FLIP_TARGET_{ABSOLUTE,RELATIVE}&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;other-capabilities&#34;&gt;Other capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_CURSOR_HEIGHT&lt;/code&gt;, &lt;code&gt;DRM_CAP_CURSOR_WIDTH&lt;/code&gt; integer. return &lt;em&gt;valid&lt;/em&gt; (not necessary the maximum) hardware cursor size.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_PRIME&lt;/code&gt;. bitfield. The device can export buffers to other GPUs and/or import buffers from them.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;obsolete-capabilities&#34;&gt;Obsolete capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_CRTC_IN_VBLANK_EVENT&lt;/code&gt;. boolean. Always true since Linux 4.12.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_TIMESTAP_MONOTONIC&lt;/code&gt;. boolean. Always true since Linux 4.15.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_VBLANK_HIGH_CRTC&lt;/code&gt;. boolean. Always true since Linux 2.6.39&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;client-capabilities&#34;&gt;Client capabilities&lt;/h2&gt;
&lt;p&gt;DRM client may indicate it has certain capabilites. This is necessary to activate backward-incompatible
functionality that would otherwise break old clients.&lt;/p&gt;
&lt;p&gt;Client capabilities are set using &lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;DRM_IOCTL_SET_CLIENT_CAP&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_STEREO_3D&lt;/code&gt;. boolean. Client can handle stereo 3D, so show it the corresponding modes in the list of modes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_UNIVERSAL_PLANES&lt;/code&gt;. integer&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. If &amp;gt; 0 then client can handle multiple planes, show it planes beyond primary and cursor ones in the list of planes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_ATOMIC&lt;/code&gt;. boolean. Client can use atomic modesetting &lt;code&gt;ioctl&lt;/code&gt;s. Also enables universal planes and aspect ratio.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_ASPECT_RATIO&lt;/code&gt;. boolean. Client can handle aspect ratio in modes, so provide it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_WRITEBACK_CONNECTORS&lt;/code&gt;. boolean. Client can handle writeback connectors (connectors that capture output and save it into a framebuffer).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dri.freedesktop.org/docs/drm/gpu/drm-uapi.html&#34;&gt;DRM uAPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux &lt;code&gt;drivers/gpu/drm/drm_ioctl.c&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Xserver modesetting DDX is completely broken: it asks for universal planes, but is not ready to
handle them. To avoid blowing up users&#39; desktops, any process with name starting with &lt;code&gt;X&lt;/code&gt; is
required to set this capability to 2 to really enable universal planes.
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/drm_ioctl.c?id=723dad977acd1bd37f87e88d430958a833491ff1#n339&#34;&gt;Yes, really&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/02-de-vt/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - Linux VT</title>
  <published>2023-07-07T00:00:00Z</published>
  <updated>2023-07-07T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/02-de-vt/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;Before drawing anything on screen compositor should ensure it
owns the screen it wants to draw on, or the results won&amp;rsquo;t look
good: several processes or kernel may draw over whatever compositor
has drawn&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Under Linux, VT subsystem draws terminals on various screens
attached to computer&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, so the compositor has to cooperate
with it. VT subsystem simulates several physical consoles on a single
display, providing functionality to create, destroy and switch between
several consoles.&lt;/p&gt;
&lt;p&gt;Consoles are named from 1 upwards and represented as character devices
&lt;code&gt;/dev/ttyN&lt;/code&gt;. One of them is active at any time. &lt;code&gt;/dev/tty0&lt;/code&gt; is alias
for the currently active console.&lt;/p&gt;
&lt;h2 id=&#34;textgraphics-mode&#34;&gt;Text/graphics mode&lt;/h2&gt;
&lt;p&gt;Every console might be in text or graphics mode. In text mode VT
subsystem draws the text, the cursor and handles idle blanking.
In graphics mode VT subsystem does not do anything. To draw anything
to screen, compositor should pick a console and switch it to graphics
mode. On exit it should restore the previous mode, or text console
won&amp;rsquo;t be redrawn&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Text/graphic mode is activated by &lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;KDSETMODE&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;vt-switching&#34;&gt;VT switching&lt;/h2&gt;
&lt;p&gt;Switching between consoles is started by by pressing a special
key&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; (handled by kernel itself), or by issuing &lt;code&gt;ioctl&lt;/code&gt;
&lt;code&gt;VT_ACTIVATE&lt;/code&gt;&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;For consoles in text mode kernel handles saving and restoring content
on switch, for graphics consoles kernel expects applications to redraw
themselves.&lt;/p&gt;
&lt;h2 id=&#34;autoprocess-controlled-vt-switching&#34;&gt;Auto/process-controlled VT switching&lt;/h2&gt;
&lt;p&gt;Every console might be in one of two modes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;auto VT switching,&lt;/li&gt;
&lt;li&gt;process-controlled VT switching.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This mode is set by &lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;VT_SETMODE&lt;/code&gt; that takes three parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the mode: auto/process-controlled&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;,&lt;/li&gt;
&lt;li&gt;the signal to send on console deactivation&lt;/li&gt;
&lt;li&gt;the signal to send on console activation (see below).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If console is in auto mode nothing happens if it is activated
(switched to) or deactivated (switched from).&lt;/p&gt;
&lt;p&gt;If console is in process-controlled mode then both activating
and deactivating console is coordinated with the process that
owns the console:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on console deactivation kernel sends the process that owns the
console being switched from a signal and awaits that process to
call &lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;VT_RELDISP&lt;/code&gt; to mark the console as released.&lt;/li&gt;
&lt;li&gt;on console activation the same happens on console being
switched to.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How kernel knows which process to send the signal to? It sends
the signal to the process that called &lt;code&gt;VT_SETMODE&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;console_ioctl(4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;seatd&lt;/code&gt; source code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Xfree86&lt;/code&gt; source code&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;For example, if compositor is started from the virtual console and uses
it instead of switching to a new one and without telling VT to stop
drawing, its own stdout and stderr will be written over the its own
output.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;If not compiled with &lt;code&gt;CONFIG_VT=n&lt;/code&gt;.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Actually, Linux contains a kludge to work around it: on console switch
Linux checks if the process that was supposed to draw on the console
died, and switches the console to text mode if it did.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Linux console input map contains actions &amp;ldquo;switch to console N&amp;rdquo;, &amp;ldquo;switch
to next console&amp;rdquo;, &amp;ldquo;switch to previous console&amp;rdquo;. In most console keymaps
these are bound to [Ctrl+]Alt+FnX, [Ctrl+]Alt+{Left,Right}.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;That&amp;rsquo;s how X server and Wayland compositors implement switching to
another VT. They disable VT console input, so they have to handle the
keys themselves.&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;code&gt;ioctl_console(2)&lt;/code&gt; manpage also lists &lt;code&gt;VT_ACKACQ&lt;/code&gt;, but that&amp;rsquo;s not a mode,
it&amp;rsquo;s an argument for &lt;code&gt;VT_RELDISP&lt;/code&gt;.&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/01-de-drm/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - Linux DRM devices</title>
  <published>2023-07-06T00:00:00Z</published>
  <updated>2023-07-06T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/01-de-drm/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;To draw anything on screen compositor should be able to communicate with display
controller and GPU&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Linux exposes them to userspace via DRM subsystem&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, as
character devices in &lt;code&gt;/dev/dri&lt;/code&gt;&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;There might be one or two devices for every display controller or GPU&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;there is always a device named &lt;code&gt;card&amp;lt;N&amp;gt;&lt;/code&gt;. It accepts all requests:
for controlling the display (KMS&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;) and for rendering operations.
If &lt;code&gt;card&amp;lt;N&amp;gt;&lt;/code&gt; belongs to a pure display controller, then it won&amp;rsquo;t accept
any rendering operations, of course. This device has a concept of
&amp;ldquo;DRM master&amp;rdquo;&amp;amp;mdash: only one process can control it at any time,
as allowing several processes change resolution, reconfigure outputs
or update screen at the same time won&amp;rsquo;t bring any useful results.&lt;/li&gt;
&lt;li&gt;GPUs typically expose second device named &lt;code&gt;renderD&amp;lt;N&amp;gt;&lt;/code&gt;. This device
accepts only rendering operations. However this device not does have the
concept of &amp;ldquo;DRM master&amp;rdquo; as rendering does not involve global operations
such as changing the display mode or updating the framebuffer, so there
is no need to limit concurrent access.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Matching &lt;code&gt;card&amp;lt;N&amp;gt;&lt;/code&gt; and &lt;code&gt;renderD&amp;lt;N&amp;gt;&lt;/code&gt; devices used to be awkward: the numbers
are not the same for the devices of one card. The algorithm was bus-dependent:
PCI/USB cards were matched by PCI/USB bus info, platform devices were matched
using device tree info. To find this information one had to scrounge around
in &lt;code&gt;/sys/dev/char/&amp;lt;N&amp;gt;/device/subystem&lt;/code&gt;. All of this is implemented in &lt;code&gt;libdrm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately, &lt;code&gt;udev&lt;/code&gt; nowadays creates symlinks in &lt;code&gt;/dev/dri/by-path&lt;/code&gt; of form
&lt;code&gt;&amp;lt;unique-id-for-card&amp;gt;-{card,render}&lt;/code&gt;, so userspace does not care about device
matching anymore.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cgit.freedesktop.org/drm/libdrm/tree/xf86drm.c&#34;&gt;libdrm&amp;rsquo;s x86drm.c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dri.freedesktop.org/docs/drm/gpu/drm-uapi.html&#34;&gt;Linux&amp;rsquo;s DRM uAPI documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Display controller is a hardware block that takes bitmaps and displays them
somewhere. It cares about outputs, links, modes etc. GPU takes a number of
rendering commands and produces a bitmap based on these commands. It cares
about triangles, shaders, textures and pixels. In PCs these two components
are usually colocated in a &amp;ldquo;graphic card&amp;rdquo;, display controller may require
bitmaps to be placed in a specialized on-card memory, and GPU may produce
bitmaps in that specialized memory.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;There exists &lt;a href=&#34;https://cgit.freedesktop.org/drm/libdrm/&#34;&gt;libdrm&lt;/a&gt; library that
hides low-level details from the applications, but it is not a transparent
wrapper, so it makes sense to understand what it actually does and what
it actually calls.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Direct rendering manager, not digital rights management.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;DRI stands for &amp;ldquo;direct rendering interface&amp;rdquo;. Historical reasons.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;These devices used to be also exposed as &lt;code&gt;/proc/dri&lt;/code&gt;. It is no longer the case.&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;There used to be a third kind of device, &lt;code&gt;controlD&amp;lt;N&amp;gt;&lt;/code&gt;, but it did nothing
and was eliminated.&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Kernel modesetting, a generic API to setup display controllers. Named
to contrast with userland modesetting, where userland poked hardware
directly to set the configuration of display controller.&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/dependencies/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">Dependencies</title>
  <published>2022-12-01T00:00:00Z</published>
  <updated>2022-12-01T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/dependencies/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;h2 id=&#34;why-dependencies-are-useful&#34;&gt;Why dependencies are useful?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Quick prototyping&lt;/li&gt;
&lt;li&gt;Bugs are someone else&amp;rsquo;s concern&lt;/li&gt;
&lt;li&gt;Reverse engineering is someone else&amp;rsquo;s concern&lt;/li&gt;
&lt;li&gt;Complicated algorithms and cryptography are someone else&amp;rsquo;s concern&lt;/li&gt;
&lt;li&gt;Security-critical code testing is someone else&amp;rsquo;s concern&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;why-dependencies-are-problematic&#34;&gt;Why dependencies are problematic?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Balooning build times&lt;/li&gt;
&lt;li&gt;Balooning build graph (hence tools slow down)&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s ideas of interfaces&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s ideas how to structure programs&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s ideas about build and code generation&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s bugs, and the authors of dependencies have their own priorities for bugfixing&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s release and deprecation schedules&lt;/li&gt;
&lt;li&gt;Conflicts due to transitive dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;useful-dependencies&#34;&gt;Useful dependencies&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Algorithmics, such as cryptography and compression&lt;/li&gt;
&lt;li&gt;Stable interfaces for unstable external systems (scraping, unstable APIs etc)&lt;/li&gt;
&lt;li&gt;Parsing, including basic network protocols: JSON, HTTP, XML et al.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By and large, less often a dependency changes (without accumulating known bugs) the more potentially useful it is.&lt;/p&gt;
&lt;h2 id=&#34;harmful-dependencies&#34;&gt;Harmful dependencies&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Trivial wrappers around REST APIs&lt;/li&gt;
&lt;li&gt;Opinionated clients, libraries, helpers&lt;/li&gt;
&lt;li&gt;Abstractions over stable interfaces, especially unstable abstractions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;an-experience-of-dependectomy-in-a-medium-scale-go-project-300-kloc&#34;&gt;An experience of dependectomy in a medium-scale Go project (~300 kLOC)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Removing dependency does not make the code longer. Majority of removals made the code shorter.&lt;/li&gt;
&lt;li&gt;Build (especially link stage) becomes significantly faster.&lt;/li&gt;
&lt;li&gt;Linting becomes significantly faster.&lt;/li&gt;
&lt;li&gt;Non-REST protocols are painful but doable (small subset of Mongo protocol and Protobuf can be written in several
hours, though it&amp;rsquo;s definitely not production-grade. The project tries to avoid these protocols in production).&lt;/li&gt;
&lt;/ul&gt;

  
    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/new-de/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">New Linux desktop environment</title>
  <published>2021-12-26T00:00:00Z</published>
  <updated>2021-12-26T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/new-de/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;I am developing a new Linux desktop environment. This may sound odd in
2021, desktop environments being a part of Linux landscape for the last
20 years, so why I&amp;rsquo;m doing it?&lt;/p&gt;
&lt;p&gt;Obviously, I&amp;rsquo;m not satisfied with the available options (not only on Linux,
but also under macOS, but there is no chance to having better desktop environment
for macOS).&lt;/p&gt;
&lt;p&gt;More specifically, I do not see an existing solution that successfully
covers the following needs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;deep work,&lt;/li&gt;
&lt;li&gt;dynamic hardware and networking environment,&lt;/li&gt;
&lt;li&gt;hackability.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;deep-work&#34;&gt;Deep work&lt;/h2&gt;
&lt;p&gt;Deep work, or work in the state of the flow, requires environment that minimises
distractions and promotes formation of habits.&lt;/p&gt;
&lt;p&gt;Existing desktop environments are not scoring high on these counts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Visible latency of desktop environments is a constant source of distraction.
One can often &lt;em&gt;see&lt;/em&gt; the lag of GNOME desktop, even on a last-generation video
card! This means keystrokes and mouse clicks often get misdelivered or lost,
and this breaks the formation of habits: one can start forming a habit by
using keystrokes or mouse actions, only to see it crumbling when one becomes
good at this habit, as latency kicks in and breaks the flow.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application laggines creates unneeded source of distraction too. While desktop
environment may not do much in this regard, there is not enough work for
detection of laggy applications popping up their windows in the middle of
unrelated operation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stability. One might think that after 20 years of development desktop environments
finally settled down, but &lt;a href=&#34;https://gitlab.gnome.org/GNOME/gnome-shell/-/commit/7298ee23e91b756c7009b4d7687dfd8673856f8b&#34;&gt;this is not what happens&lt;/a&gt;.
Due to lack of hackability (see below), this makes upgrades very disruptive.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Notification systems are a nuisance, and desktop environments, while
acknowledging their distraction potential, and providing crude ways to disable
notifications, do not have a good solution for important, non-urgent
notifications.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dynamic-hardware-and-networking-environment&#34;&gt;Dynamic hardware and networking environment&lt;/h2&gt;
&lt;p&gt;Desktop environments are no longer used on PCs encased in tower cases sitting
on the floor with peripherals connected to them before boot. Hence the
desktop environment has to give user the control over the hardware and networks
coming and going dynamically, and the following is the &lt;em&gt;minimal&lt;/em&gt; list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WiFi connectivity&lt;/li&gt;
&lt;li&gt;Mobile broadband connectivity&lt;/li&gt;
&lt;li&gt;VPNs&lt;/li&gt;
&lt;li&gt;Bluetooth input and output (keyboards, mices, trackpads, audio)&lt;/li&gt;
&lt;li&gt;USB peripheral devices (mass storage, eGPUs)&lt;/li&gt;
&lt;li&gt;Displays (HDMI, DisplayPort, Thunderbolt, DB-over-USB tunneling)&lt;/li&gt;
&lt;li&gt;Thunderbolt access control&lt;/li&gt;
&lt;li&gt;Various weird stuff, like pairing Logitech mice and keyboards using
their special dongles.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This rules out any Wayland compositors except KDE and GNOME: like X11 window
managers, many niche Wayland compositors are scoring high in the &amp;ldquo;deep work&amp;rdquo;
department, but they do not provide the user with any tools for hardware
management.&lt;/p&gt;
&lt;p&gt;As a side-note, wlroots-enabled compositors are doubly disqualified
&lt;a href=&#34;https://github.com/danvd/wlroots-eglstreams&#34;&gt;as wlroots project won&amp;rsquo;t merge support for NVidia drivers due to political reasons&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;hackability&#34;&gt;Hackability&lt;/h2&gt;
&lt;p&gt;If the software was perfect, hackability won&amp;rsquo;t be needed. Alas it is not, so
to overcome the imperfections of software we still have to improve it.&lt;/p&gt;
&lt;p&gt;Hackability is a freedom often touted by open source advocates, but this
freedom is very hard to exercise in reality for existing desktop
environments.&lt;/p&gt;
&lt;p&gt;Imagine a single person trying to change a way GNOME shell works. How does one
learn how to do it, how does one prepare, how does one execute the change, and
how does one integrate this change?&lt;/p&gt;
&lt;p&gt;Direct dependencies of &lt;code&gt;gnome-shell&lt;/code&gt; package in Debian include 64 packages,
including JavaScript and Python interpreters. The whole list of obviously
GNOME-related indirect dependencies is over a hundred packages long.&lt;/p&gt;
&lt;p&gt;How does one understand which piece of code to change? By wading around in the
source code that contains tons of boilerplate?&lt;/p&gt;
&lt;p&gt;How does one create a debug environment for experimenting with GNOME shell?
GNOME shell contains a lot of C code, so all the libraries have to be rebuilt in
debug mode. I don&amp;rsquo;t see a documentation how to do it in a way that does not
ruin the system one is developing on. NixOS comes close, and actually provides
a way to integrate changes back to the running system, but
&lt;a href=&#34;/2021/10/18/linux-is-not-os&#34;&gt;it comes with its own set of drawbacks&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once this is done, how one uses the changed code, especially if the fix is not
in the shell itself (as a leaf package it could easily be replaced), but in a
library? What if the change is spread over several packages?&lt;/p&gt;
&lt;p&gt;Hackability can&amp;rsquo;t be introduced into a large system once it&amp;rsquo;s built, so
there is no hope it can be added to existing desktop environments.&lt;/p&gt;
&lt;h2 id=&#34;project&#34;&gt;Project&lt;/h2&gt;
&lt;p&gt;The project is named &lt;a href=&#34;https://github.com/5de&#34;&gt;5DE&lt;/a&gt;, and the goals for the project
are as stated above: try to make a Linux desktop environment that facilitates
deep work, handles dynamic hardware/networking environment of computers and
provides hackability.&lt;/p&gt;
&lt;p&gt;There is not much there yet, and I will be documenting its progress in this blog
for the time being.&lt;/p&gt;

  
    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/linux-is-not-os/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">Linux is not OS</title>
  <published>2021-10-18T00:00:00Z</published>
  <updated>2021-10-18T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/linux-is-not-os/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;TL;DR: Every Linux distribution is a separate OS. Niche Linux distributions will
never enjoy even the modest application selection available for mainstream Linux
distributions.&lt;/p&gt;
&lt;h2 id=&#34;operating-systems-and-why-they-matter&#34;&gt;Operating systems and why they matter&lt;/h2&gt;
&lt;p&gt;Operating system is software that sits directly atop computer hardware, and performs multiple functions, namely&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sharing resources between applications,&lt;/li&gt;
&lt;li&gt;isolating applications from each other,&lt;/li&gt;
&lt;li&gt;providing applications with a stable interface to access the hardware.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Operating systems by themselves are useless, they exist solely to enable
applications to be run.&lt;/p&gt;
&lt;p&gt;Stable interface is the crucial invention that enables applications: without it
every application would have to be ported to every combination of hardware in
existence, an untenable task&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2 id=&#34;linux-distributions-are-operating-systems&#34;&gt;Linux distributions are operating systems&lt;/h2&gt;
&lt;p&gt;Operating system is defined by its interface: syscalls, file layout, packages
and package managers, services and libraries, function call ABI etc.&lt;/p&gt;
&lt;p&gt;Linux and GNU projects do not produce operating systems. Both projects produce
source code, one for the kernel, another for userspace components.&lt;/p&gt;
&lt;p&gt;Every Linux distribution takes the source code produced by Linux, GNU and other
projects, and combines them into an operating system, deciding on syscall
interface, file layout, available libraries and other aspects that together
specify the operating system interface.&lt;/p&gt;
&lt;p&gt;Different distributions make different choices, and therefore they are closely
related operating systems, but not a single OS. Even Linux syscall interface
subtly changes from distribution to distribution, as they pick and choose
options to build their kernels.&lt;/p&gt;
&lt;p&gt;In practice this means that application developers are unable to target &amp;ldquo;Linux&amp;rdquo;,
they have to target many Linux distributions. This is most evident when clicking
&amp;ldquo;Download&amp;rdquo; button that opens a menu with the set of packages to choose from, but
even if the package for a particular package manager is available, the installed
application may not work if it was not tested on this particular distribution.&lt;/p&gt;
&lt;h2 id=&#34;consequences-for-niche-linux-distributions&#34;&gt;Consequences for niche Linux distributions&lt;/h2&gt;
&lt;p&gt;Every niche Linux distribution that does not follow the interface of a larger
one is a unique OS, closely related but not compatible with other Linux OSes.
This means the applications have to be ported.&lt;/p&gt;
&lt;p&gt;Application developers have to choose what targets their applications support.
With Linux distributions being just a blip on the graph of operating systems
popularity, the application developers may not invest significant amount of
resources into porting and testing.&lt;/p&gt;
&lt;p&gt;Even this blip is hopelessly fragmented: there are hundreds of Linux
distributions. Therefore the only realistic option for application developers is
to care about several largest distributions, if they care about Linux at all.&lt;/p&gt;
&lt;p&gt;This places the burden of porting and testing on the niche distribution makers,
which means that the only most popular and easily ported applications will be
available.&lt;/p&gt;
&lt;h2 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;h3 id=&#34;arent-snap-and-flatpak-designed-to-run-applications-on-any-linux-distribution&#34;&gt;Aren&amp;rsquo;t Snap and Flatpak designed to run applications on any Linux distribution?&lt;/h3&gt;
&lt;p&gt;This is true. Snap and Flatpak can be seen as virtualized operating systems.&lt;/p&gt;
&lt;p&gt;Some underlying variations still leak through the abstraction (e.g. the set of
supported Linux syscalls may vary based on distribution&amp;rsquo;s kernel configuration),
but the resulting ABI is way stabler than the native one.&lt;/p&gt;
&lt;p&gt;This is the easiest way to target Linux for applications that do not need
services beyond what Snap and Flatpak provide.&lt;/p&gt;
&lt;h3 id=&#34;shouldnt-application-authors-stick-to-the-published-api-and-let-distribution-authors-build-and-package-their-software&#34;&gt;Shouldn&amp;rsquo;t application authors stick to the published API, and let distribution authors build and package their software?&lt;/h3&gt;
&lt;p&gt;This is totally fine. However note that this means application authors merely
supply more raw ingredients, and distribution authors have to make/port
applications for their OS out of these ingredients&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h3 id=&#34;shouldnt-application-authors-stick-to-the-standards-to-make-porting-trivial&#34;&gt;Shouldn&amp;rsquo;t application authors stick to the standards to make porting trivial?&lt;/h3&gt;
&lt;p&gt;It does not work.&lt;/p&gt;
&lt;p&gt;First, there aren&amp;rsquo;t many great standards out there to stick to. LSB is outdated.
SUSv4 only covers basic syscalls and shell. X11 and Wayland are low-level, and
contain numerous extensions.&lt;/p&gt;
&lt;p&gt;Second, existing standards cover a small subset of functionality provided by
Linux and userspace libraries. Standards do not cover &lt;code&gt;signalfd(2)&lt;/code&gt; or GTK4.&lt;/p&gt;
&lt;p&gt;Third, even if porting is made relatively trivial, there is additional per-OS
work of testing the application. Application authors have at least be aware of
existence of a particular niche distribution to be able to test and release
their application, and with distributions counting in hundreds this is not
feasible.&lt;/p&gt;
&lt;h3 id=&#34;i-dont-care-about-anything-thats-not-packaged-by-the-distribution&#34;&gt;I don&amp;rsquo;t care about anything that&amp;rsquo;s not packaged by the distribution&lt;/h3&gt;
&lt;p&gt;This is totally fine. Just note that you are using a niche OS with a limited set
of applications available.&lt;/p&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Some small platforms (ZX Spectrum, C64) could get away with it for a while by having a stable set of hardware, however this approach does not work long-term, due to sheer number of computer components and periphery produced.
Manufacturers of these platforms got bitten by the hardware stability when they introduced new versions of their computers.
Application developers were disincentivised to use new features because they also had to target large install base of older computers, so new computers didn&amp;rsquo;t provide any benefits to the end users due to lack of applications, and both Sinclair and Commodore ultimately closed down.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Moreover, a free software license is not a universally sound choice for software authors. This limits the set of applications available for the distributions that insist that the application packaging and testing has to be done by the distribution maintainers.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>


</feed>
