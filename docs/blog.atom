<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0">
  <id>https://dottedmag.net/</id>
  <title>Mikhail Gusarov</title>
  
  <updated>2023-07-10T00:00:00Z</updated>
  
  <author><name>Mikhail Gusarov</name></author>
  <link href="https://dottedmag.net/" rel="alternate"></link>
  <link href="https://dottedmag.net/blog.atom" rel="self"></link>



<entry>
  <id>https://dottedmag.net/blog/06-de-drm-framebuffer/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - DRM framebuffers (1)</title>
  <published>2023-07-10T00:00:00Z</published>
  <updated>2023-07-10T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/06-de-drm-framebuffer/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;&lt;a href=&#34;/blog/05-de-drm-pipeline/&#34;&gt;Display controller pipeline&lt;/a&gt; takes framebuffers as input.&lt;/p&gt;
&lt;p&gt;Framebuffer in DRM is a raster picture. Graphics display hardware is very particular
about location and layout of that memory, and the details vary significantly between
cards, so DRM provides some common functionality and leaves the rest to drivers.&lt;/p&gt;
&lt;p&gt;A framebuffer consists of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a chunk of memory (may be several chunks for pictures that are composed of several planes&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;width, height information, in pixels&lt;/li&gt;
&lt;li&gt;pitch (also known as stride): number of bytes between successive lines of picture&lt;/li&gt;
&lt;li&gt;pixel format and modifier (see below)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Display controllers are very particular about data format as they have to be able to scan
and combine several megabytes&#39; worth of data fast enough to generate video signal for every frame,
so DRM planes have restrictions on pixel formats they accept.&lt;/p&gt;
&lt;h2 id=&#34;memory-handles&#34;&gt;Memory handles&lt;/h2&gt;
&lt;p&gt;Display controller or GPU might have their own memory space, so DRM uses &lt;em&gt;handles&lt;/em&gt; to allocated
memory. Some of these handles may be &lt;code&gt;mmap&lt;/code&gt;ed to obtain memory pointers though it might be very
slow.&lt;/p&gt;
&lt;h2 id=&#34;framebuffer-formats-and-modifiers&#34;&gt;Framebuffer formats and modifiers&lt;/h2&gt;
&lt;p&gt;Display controller needs to know how data in framebuffer is laid aout to know how to interpret
it. This is indicated by pixel format and optional modifier. There are lots of formats and
modifiers specified in &lt;code&gt;drm/drm_fourcc.h&lt;/code&gt;. Formats are four-letter codes, modifiers are 32-bit
integers.&lt;/p&gt;
&lt;p&gt;Pixel formats typically specify how one pixel is laid out: single-planar/multi-planar layout,
order of components within a pixel, width and interpretation of every component.&lt;/p&gt;
&lt;p&gt;Pixel formats also can be classified as single-plane and multi-plane. Single-plane store all
information for a pixel in one place, multi-plane formats store components of the pixel
separately, with every plane (chunk of memory) laying out components of pixels in the same order.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;DRM_FORMAT_ABGR1555&lt;/code&gt; is defined as &lt;code&gt;[15:0] B:G:R:x 5:5:5:1 little endian&lt;/code&gt;:
single-planar, RGB, one pixel occupies 16 bits, 5 bits of blue, green, red components
and 1 bit of alpha.&lt;/p&gt;
&lt;p&gt;Some formats are more cryptic: &lt;code&gt;DRM_FORMAT_YUV444&lt;/code&gt; is &lt;code&gt;non-subsampled Cr (1) and Cb (2) planes&lt;/code&gt;:
YCbCr, 3 planes, 8 bit Y plane, 8 bit Cr plane, 8 bit Cb plane.&lt;/p&gt;
&lt;p&gt;Pixel format modifiers typically specify how multiple pixels are laid out in memory: there
is &lt;code&gt;DRM_FORMAT_MOD_LINEAR&lt;/code&gt; to force linear layout (pixels are laid out in memory one after
another, left-to-right, top-to-bottom, with a possible padding between rows), and a number
of modifiers to specify various tiling layouts (clumps of nearby pixels are stored
in memory together) and framebuffer compression algorithms.&lt;/p&gt;
&lt;p&gt;Every DRM plane exposes supported formats, so it&amp;rsquo;s up to userspace to pick one for best
performance. Some DRM planes are specifically created to speedup frequent operations: it is
common to see overlay planes that support YUV pixel formats for video playback: many video
formats encode picture in YUV, so it allows decoding video directly into a framebuffer and
skipping YUV-&amp;gt;RGB conversion.&lt;/p&gt;
&lt;h2 id=&#34;dumb-buffers&#34;&gt;Dumb buffers&lt;/h2&gt;
&lt;p&gt;Display controllers differ wildly in their requirements for memory allocation, so DRM drivers
expose driver-specific &lt;code&gt;ioctl&lt;/code&gt;s for that, and rely on userspace to properly drive the hardware.
However, requiring full Mesa to draw anything at all is a bit excessive, so DRM drivers also
expose &lt;em&gt;dumb buffers&lt;/em&gt;: a limited API for allocating memory. Dumb buffers are allowed to be
very slow, so they are provided mainly for diagnostic messages, splash screens and similar
circumstances where speed is not a concern.&lt;/p&gt;
&lt;p&gt;A dumb buffer is allocated using &lt;code&gt;DRM_IOCTL_MODE_CREATE_DUMB&lt;/code&gt; that takes width, height, and bpp
of the buffer to be allocated. Buffer handle and pitch is returned. Dumb buffers can always
be passed to DRM to draw images with (other types of buffers may not be, e.g. if they are
GPU-only).&lt;/p&gt;
&lt;p&gt;Dumb buffers may be &lt;code&gt;mmap&lt;/code&gt;ed using &lt;code&gt;DRM_IOCTL_MODE_MAP_DUMB&lt;/code&gt; and destroyed using
&lt;code&gt;DRM_IOCTL_MODE_DESTROY_DUMB&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;DRM driver indicates dumb buffer support by &lt;code&gt;DRM_CAP_DUMB_BUFFER&lt;/code&gt; capability.&lt;/p&gt;
&lt;p&gt;These drivers also expose &lt;code&gt;DRM_CAP_DUMB_PREFERRED_DEPTH&lt;/code&gt; capability for preferred depth
(some drivers are unable to allocate dumb buffer of depth different from preferred),
and &lt;code&gt;DRM_CAP_DUMB_PREFER_SHADOW&lt;/code&gt; to indicate that random access to dumb buffers is very slow,
and applications should render somewhere else and batch-copy data to dumb buffer once done.&lt;/p&gt;
&lt;h2 id=&#34;non-dumb-buffers&#34;&gt;Non-dumb buffers&lt;/h2&gt;
&lt;p&gt;Non-dumb buffers are complicated and will be discussed in another post.&lt;/p&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Framebuffer planes are unrelated to DRM planes, even though the idea is similar: take several
memory buffers and produce a combined picture. Plane image formats actually precede modern
display controllers by a significant margin: NES used planar graphics back in 1983.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/05-de-drm-pipeline/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - DRM pipeline</title>
  <published>2023-07-09T00:00:00Z</published>
  <updated>2023-07-09T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/05-de-drm-pipeline/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;Once compositor has obtained the control over graphics hardware, it needs to find
out what&amp;rsquo;s available for use.&lt;/p&gt;
&lt;p&gt;DRM exposes display controllers using the following objects: framebuffers, planes, CRTCs, connectors and encoders.&lt;/p&gt;
&lt;h2 id=&#34;framebuffers&#34;&gt;Framebuffers&lt;/h2&gt;
&lt;p&gt;Framebuffer is a bunch of pixels in memory with metadata (size, pixel format, memory layout).&lt;/p&gt;
&lt;p&gt;Framebuffers are typically an output of rendering, either GPU or CPU.&lt;/p&gt;
&lt;h2 id=&#34;crtcs-and-planes&#34;&gt;CRTCs and planes&lt;/h2&gt;
&lt;p&gt;Display controllers combine several framebuffers into one picture and display this picture
on physical displays.&lt;/p&gt;
&lt;p&gt;CRTC&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; is an abstraction of a display controller: it takes a number of framebuffers using
&lt;em&gt;planes&lt;/em&gt;, global display propeties, such as display mode, gamma and VRR; and a number of
&lt;em&gt;connectors&lt;/em&gt; that represent hardware outputs.&lt;/p&gt;
&lt;p&gt;Plane is a slot for a framebuffer, plus information needed for combining several planes into a
picture: position, rotation and scaling of framebuffer, blend mode, Z-position and color information.&lt;/p&gt;
&lt;p&gt;Planes traditionally have roles: &amp;ldquo;primary&amp;rdquo;, &amp;ldquo;cursor&amp;rdquo; and &amp;ldquo;overlay&amp;rdquo;. DRM is role-agnostic, but
these roles hint on their expected uses (e.g. cursor planes may be limited in size and overlay
planes may support YUV pixel fomats).&lt;/p&gt;
&lt;p&gt;A set of CRTCs and planes is fixed, and they may be matched many-to-many, though in many cards
a plane is compatible with only one CRTC. When a plane is compatible with multiple CRTCs, it
is typically an overlay plane compatible with any of them. For some devices all planes are
compatible with all CRTCs.&lt;/p&gt;
&lt;p&gt;Planes and CRTCs are bound to one DRM device: a plane from one device cannot be compatible with
CRTC from another device.&lt;/p&gt;
&lt;h2 id=&#34;connectors-and-encoders&#34;&gt;Connectors and encoders&lt;/h2&gt;
&lt;p&gt;Connector is a hardware output port of a display controller (think VGA or DisplayPort output).
Some connectors are wired permanently, some come and go (e.g. connecting a USB-C hub with
DisplayPort outputs causes new connectors to appear).&lt;/p&gt;
&lt;p&gt;Connectors store output information (state of the link, DPMS state, EDID, tiling information
for tiled displays and so on).&lt;/p&gt;
&lt;p&gt;Encoder represents a piece of hardware inside a display controller that converts pixels into
the electrical signals of a display protocol (e.g. TMDS encoder provides signals for HDMI,
DAC encoder for VGA or S-Video). Encoders are static.&lt;/p&gt;
&lt;p&gt;Not all CRTCs are wired to supply all encoders, and not all encoders can supply all connectors,
so compositors should solve the constraints to properly select CRTCs for outputs.&lt;/p&gt;
&lt;h3 id=&#34;writeback-connectors&#34;&gt;Writeback connectors&lt;/h3&gt;
&lt;p&gt;Connectors of &amp;ldquo;writeback&amp;rdquo; type are special: instead of displaying the picture on a display,
they copy it into associated framebuffer.&lt;/p&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Cathode-ray tube controller. Yeah.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/principle-codenames/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">Codenames</title>
  <published>2023-07-08T00:00:00Z</published>
  <updated>2023-07-08T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/principle-codenames/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;Codenames are useful.&lt;/p&gt;
&lt;p&gt;Whenever we develop software we invent names. Tons of names. VCS repository
names, directory names, executable names, package names, class names, function
names, configuration file names, database names, usernames. The list goes on.&lt;/p&gt;
&lt;p&gt;A natural impulse is to use your product&amp;rsquo;s name in these names. After all,
if you are developing X it makes sense to name things after X.&lt;/p&gt;
&lt;p&gt;The problem is that most of the time we don&amp;rsquo;t know how the project will turn
out: the product might (and probably will) change its the target audience,
format and may metamorphose completely.&lt;/p&gt;
&lt;p&gt;You can guess what happens in this case: public-facing identifiers will
be changed quickly, but internal ones will linger: the ones that are easy to
change will be changed eventually, the ones that are hard will get stuck.&lt;/p&gt;
&lt;p&gt;Now imagine the public name changing several times over the lifetime of the
project.&lt;/p&gt;
&lt;p&gt;The codebase will accrete all names used by the product in past. From time to
time a heroic effort will be applied to clean the old cruft, as it becomes
harder and harder to explain to new team members that X, Y, Z and W are
actually the same thing. It will &lt;em&gt;mostly&lt;/em&gt; succeed, except that one place
that requires somebody to spend an hour in a SaaS console somewhere&amp;hellip; However
there is a backlog of features, so let&amp;rsquo;s postpone it to another day&amp;hellip;&lt;/p&gt;
&lt;p&gt;Changing identifiers is a huge waste of time. Use codenames instead.&lt;/p&gt;
&lt;p&gt;Codename is an internal techincal identifier. It is guarded from marketing.
It is not allowed to escape to the public. It is stable. It is used everywhere
where internal identifiers are needed, starting from the name of VCS repository.&lt;/p&gt;
&lt;p&gt;Use codenames as much as you can. Don&amp;rsquo;t leak them to the users though.&lt;/p&gt;
&lt;p&gt;P.S: If you develop desktop software, more details of your software leak
to the users: configuration files or main executables should be named
after marketing name. The life is much easier for SaaS or mobile apps:
user-facing domains, UIs, marketplace entries and APIs have to use marketing
names, everything else is hidden from the users and should use the codename.&lt;/p&gt;

  
    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/04-de-drm-ioctl-2/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - DRM operations - resource sharing</title>
  <published>2023-07-08T00:00:00Z</published>
  <updated>2023-07-08T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/04-de-drm-ioctl-2/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;Graphics hardware might need to be shared by the compositor and applications.&lt;/p&gt;
&lt;p&gt;Compositor is in charge of display controller as a final arbiter of what goes to screen
(except leasing, see below), but applications need access to rendering functionality.
Several compositors need to share hardware too.&lt;/p&gt;
&lt;h2 id=&#34;giving-application-access-to-the-rendering&#34;&gt;Giving application access to the rendering&lt;/h2&gt;
&lt;p&gt;Application (actually, usually Mesa on behalf of application) opens rendering device node,
uses it for rendering. Easy&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sharing-a-display-controller-between-compositors&#34;&gt;Sharing a display controller between compositors&lt;/h2&gt;
&lt;p&gt;There is a concept of &amp;ldquo;DRM master&amp;rdquo;: an application that owns the display controller functionality
in DRM. First process that opens DRM card device becomes master automatically.&lt;/p&gt;
&lt;p&gt;Whenever a compositor needs to yield access to display controller to another compositor,
it issues &lt;code&gt;DRM_IOCTL_DROP_MASTER&lt;/code&gt;. Whenever it needs to become a master again, it
issues &lt;code&gt;DRM_IOCTL_SET_MASTER&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This dance is typically performed in &lt;a href=&#34;/blog/02-de-vt/&#34;&gt;VT switch sequence&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;handing-over-the-display-controller-to-the-application&#34;&gt;Handing over the display controller to the application&lt;/h2&gt;
&lt;p&gt;Sometimes an application needs full control over a display controller. Typically it happens
when a display controller is a part of specialized device, such as VR hardware. In this case
compositor may &lt;em&gt;lease&lt;/em&gt; a DRM device to an application.&lt;/p&gt;
&lt;p&gt;Compositor calls &lt;code&gt;DRM_IOCTL_MODE_CREATE_LEASE&lt;/code&gt; with a set of DRM objects it wants to
lease, gets back a new DRM file descriptor and passes it to the application.&lt;/p&gt;
&lt;p&gt;Compositor may list the active leases with &lt;code&gt;DRM_IOCTL_LIST_LESSEES&lt;/code&gt;, leased objects
using &lt;code&gt;DRM_IOCTL_GET_LEASE&lt;/code&gt; and yank control back at any time using &lt;code&gt;DRM_IOCTL_REVOKE_LEASE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Application can use new file descriptor as if it is a real DRM master.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.x.org/wiki/Events/XDC2013/XDC2013DavidHerrmannDRMSecurity/slides.pdf&#34;&gt;DRM security&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wlroots&lt;/code&gt; source code&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keithp.com/blogs/DRM-lease/&#34;&gt;DRM lease&lt;/a&gt;, &lt;a href=&#34;https://keithp.com/blogs/DRM-lease-2/&#34;&gt;DRM lease-2&lt;/a&gt;, &lt;a href=&#34;https://keithp.com/blogs/DRM-lease-3/&#34;&gt;DRM lease-3&lt;/a&gt; keithp blog posts.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;This used to be much more complicated. Before rendering devices were introduced, applications
opened card devices, used &lt;code&gt;DRM_IOCTL_GET_MAGIC&lt;/code&gt; to obtain a magic cookie, passed it
to the compositor that used &lt;code&gt;DRM_IOCTL_AUTH_MAGIC&lt;/code&gt; to allow applications to render.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/03-de-drm-ioctl/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - DRM operations - capabilites</title>
  <published>2023-07-08T00:00:00Z</published>
  <updated>2023-07-08T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/03-de-drm-ioctl/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;What can compositor do with DRM devices once it &lt;a href=&#34;/blog/01-de-drm/&#34;&gt;has found&lt;/a&gt; them?&lt;/p&gt;
&lt;p&gt;These devices respond to a number of &lt;code&gt;ioctl&lt;/code&gt;s. All DRM devices respond to a set
of common &lt;code&gt;ioctl&lt;/code&gt;s that cover display controller functionality, and there are
driver-specific &lt;code&gt;ioctl&lt;/code&gt;s used chiefly by Mesa for rendering operations.&lt;/p&gt;
&lt;p&gt;The list of &lt;code&gt;ioctl&lt;/code&gt;s is pretty large, so this post covers only a small subset.&lt;/p&gt;
&lt;h2 id=&#34;versions&#34;&gt;Versions&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DRM_IOCTL_VERSION&lt;/code&gt; returns human-readable version, name, description
and (release?) date of DRM device.&lt;/p&gt;
&lt;h2 id=&#34;device-capabilities&#34;&gt;Device capabilities&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DRM_IOCTL_GET_CAP&lt;/code&gt; returns capabilities of a DRM device.&lt;/p&gt;
&lt;p&gt;Many of these capabilities refer to specific DRM &lt;code&gt;ioctl&lt;/code&gt;s, so they may not
make much sense yet.&lt;/p&gt;
&lt;h3 id=&#34;framebuffer-capabilities&#34;&gt;Framebuffer capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_ADDFB2_MODIFIERS&lt;/code&gt;. boolean. Framebuffers support pixel format modifiers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_DUMB_BUFFER&lt;/code&gt;. boolean. The device can create dumb framebuffers (&lt;code&gt;DRM_IOCTL_MODE_CREATE_DUMB&lt;/code&gt; et al)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_DUMB_PREFERRED_DEPTH&lt;/code&gt;. integer. The preferred pixel depth of dumb framebuffers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_DUMB_PREFER_SHADOW&lt;/code&gt;. boolean. Non-sequential writes or reading from dumb framebuffer is slow.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;syncobj-capabilities&#34;&gt;Syncobj capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_SYNCOBJ&lt;/code&gt;. boolean. The device supports DRM sync objects.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_SYNCOBJ_TIMELINE&lt;/code&gt;. boolean. The device supports DRM timeline sync objects
(they can signal at specific points in their lifetimes).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;page-flipping-capabilities&#34;&gt;Page flipping capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_ASYNC_PAGE_FLIP&lt;/code&gt;. boolean. The device can pageflip without delay (tearing pageflip).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_PAGE_FLIP_TARGET&lt;/code&gt;. boolean. The device can pageflip with a specified target
(&lt;code&gt;DRM_MODE_PAGE_FLIP_TARGET_{ABSOLUTE,RELATIVE}&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;other-capabilities&#34;&gt;Other capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_CURSOR_HEIGHT&lt;/code&gt;, &lt;code&gt;DRM_CAP_CURSOR_WIDTH&lt;/code&gt; integer. return &lt;em&gt;valid&lt;/em&gt; (not necessary the maximum) hardware cursor size.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_PRIME&lt;/code&gt;. bitfield. The device can export buffers to other GPUs and/or import buffers from them.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;obsolete-capabilities&#34;&gt;Obsolete capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_CRTC_IN_VBLANK_EVENT&lt;/code&gt;. boolean. Always true since Linux 4.12.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_TIMESTAP_MONOTONIC&lt;/code&gt;. boolean. Always true since Linux 4.15.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CAP_VBLANK_HIGH_CRTC&lt;/code&gt;. boolean. Always true since Linux 2.6.39&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;client-capabilities&#34;&gt;Client capabilities&lt;/h2&gt;
&lt;p&gt;DRM client may indicate it has certain capabilites. This is necessary to activate backward-incompatible
functionality that would otherwise break old clients.&lt;/p&gt;
&lt;p&gt;Client capabilities are set using &lt;code&gt;DRM_IOCTL_SET_CLIENT_CAP&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_STEREO_3D&lt;/code&gt;. boolean. Client can handle stereo 3D, so show it the corresponding modes in the list of modes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_UNIVERSAL_PLANES&lt;/code&gt;. integer&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. If &amp;gt; 0 then client can handle multiple planes, show it planes beyond primary and cursor ones in the list of planes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_ATOMIC&lt;/code&gt;. boolean. Client can use atomic modesetting &lt;code&gt;ioctl&lt;/code&gt;s. Also enables universal planes and aspect ratio.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_ASPECT_RATIO&lt;/code&gt;. boolean. Client can handle aspect ratio in modes, so provide it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DRM_CLIENT_CAP_WRITEBACK_CONNECTORS&lt;/code&gt;. boolean. Client can handle writeback connectors (connectors that capture output and save it into a framebuffer).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dri.freedesktop.org/docs/drm/gpu/drm-uapi.html&#34;&gt;DRM uAPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux &lt;code&gt;drivers/gpu/drm/drm_ioctl.c&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Xserver modesetting DDX is completely broken: it asks for universal planes, but is not ready to
handle them. To avoid blowing up users&#39; desktops, any process with name starting with &lt;code&gt;X&lt;/code&gt; is
required to set this capability to 2 to really enable universal planes.
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/drm_ioctl.c?id=723dad977acd1bd37f87e88d430958a833491ff1#n339&#34;&gt;Yes, really&lt;/a&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/02-de-vt/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - Linux VT</title>
  <published>2023-07-07T00:00:00Z</published>
  <updated>2023-07-07T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/02-de-vt/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;Before drawing any visuals on screen, the compositor must ensure it
owns the screen it wishes to draw on. If it doesn&amp;rsquo;t, the results
won&amp;rsquo;t look good, as multiple processes or the kernel may draw over
the compositor&amp;rsquo;s output&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;In Linux, VT subsystem draws terminals across multiple screens
attached to computer&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, so the compositor needs to cooperate
with it. The VT subsystem emulates multiple physical consoles on a single
display, providing functionality to add, destroy and switch between
these consoles.&lt;/p&gt;
&lt;p&gt;Consoles are numbered beginning from 1 and represented as character
devices &lt;code&gt;/dev/ttyN&lt;/code&gt;. Only one of them is active at a time. &lt;code&gt;/dev/tty0&lt;/code&gt; is
an alias for the currently active console.&lt;/p&gt;
&lt;h2 id=&#34;textgraphics-mode&#34;&gt;Text/graphics mode&lt;/h2&gt;
&lt;p&gt;Every console can be in text or graphics mode. In text mode, the VT
subsystem manages text rendering, cursor display and idle blanking.
In graphics mode, the VT subsystem does not do anything. To draw anything
on the screen, the compositor must pick a console and switch it to graphics
mode. On exit, it must restore the previous mode; otherwise the text console
will not be redrawn&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;The text/graphic mode is selected by &lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;KDSETMODE&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;vt-switching&#34;&gt;VT switching&lt;/h2&gt;
&lt;p&gt;Switching between consoles begins by pressing a special
key&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; (managed by the kernel itself), or by issuing &lt;code&gt;ioctl&lt;/code&gt;
&lt;code&gt;VT_ACTIVATE&lt;/code&gt;&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;The kernel manages the saving and restoring of content for consoles in text mode.
For graphics consoles, the kernel expects applications to self-redraw.&lt;/p&gt;
&lt;h2 id=&#34;autoprocess-controlled-vt-switching&#34;&gt;Auto/process-controlled VT switching&lt;/h2&gt;
&lt;p&gt;Every console can be in one of two modes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;automatic VT switching,&lt;/li&gt;
&lt;li&gt;process-controlled VT switching.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The mode is selected by &lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;VT_SETMODE&lt;/code&gt; that takes three parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the mode: auto or process-controlled&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;,&lt;/li&gt;
&lt;li&gt;the signal sent on console deactivation (release signal)&lt;/li&gt;
&lt;li&gt;the signal sent on console activation (acquire signal).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The process that called this &lt;code&gt;ioctl&lt;/code&gt; becomes the console owner.&lt;/p&gt;
&lt;p&gt;If the console is in auto mode, nothing happens when it is activated
(switched to) or deactivated (swiched from).&lt;/p&gt;
&lt;p&gt;If the console is in process-controlled mode, both its activation
and deactivation are coordinated with the owning process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on deactivation, the kernel sends the release signal to the owning process.
The kernel then waits for that process to call &lt;code&gt;ioctl&lt;/code&gt; &lt;code&gt;VT_RELDISP&lt;/code&gt;,
marking the console as released.&lt;/li&gt;
&lt;li&gt;The same procedure occurs on console activation: the acquire signal is
sent to the owner of the console being switched to.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;console_ioctl(4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;seatd&lt;/code&gt; source code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Xfree86&lt;/code&gt; source code&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;For instance, if compositor is started from the virtual console, using
it directly instead of switching to a new one, and without compositor
telling VT to stop drawing, its own stdout and stderr will overwrite
its output.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;If it is not compiled with &lt;code&gt;CONFIG_VT=n&lt;/code&gt;.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Actually, Linux includes a kludge for this situation: whenever console
switch occurs, it checks whether the owning process has died. If it did,
Linux switches the console back to text mode.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;The Linux console input map provides actions &amp;ldquo;switch to console N&amp;rdquo;, &amp;ldquo;switch
to next console&amp;rdquo; and &amp;ldquo;switch to previous console&amp;rdquo;. Typcially, these actions
are bound to key combinations [Ctrl+]Alt+FnX, [Ctrl+]Alt+{Left,Right}.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;That&amp;rsquo;s how X server and Wayland compositors implement switching to
another VT. They disable the VT console input, so they must handle the
keys themselves.&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;code&gt;ioctl_console(2)&lt;/code&gt; manpage also mentions &lt;code&gt;VT_ACKACQ&lt;/code&gt;, but it&amp;rsquo;s not a mode;
instead, it&amp;rsquo;s an argument for &lt;code&gt;VT_RELDISP&lt;/code&gt;.&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/01-de-drm/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - Linux DRM devices</title>
  <published>2023-07-06T00:00:00Z</published>
  <updated>2023-07-06T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/01-de-drm/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;To draw on the screen, the compositor needs to communicate with the display
controller and GPU&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Linux exposes them to userspace via DRM subsystem&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, which presents them
as character devices in &lt;code&gt;/dev/dri&lt;/code&gt;&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;There could be one or two devices per display controller or GPU&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;there is always a device named &lt;code&gt;card&amp;lt;N&amp;gt;&lt;/code&gt; that accepts all requests
for controlling the display (KMS&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;) and rendering operations.
If &lt;code&gt;card&amp;lt;N&amp;gt;&lt;/code&gt; belongs to a pure display controller, it won&amp;rsquo;t accept
rendering operations.&lt;/li&gt;
&lt;li&gt;GPUs typically have a second device called &lt;code&gt;renderD&amp;lt;N&amp;gt;&lt;/code&gt;. It is dedicated
to rendering operations only.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Card and render devices for one card do not have the same number in the name.
To match them, use symlinks in &lt;code&gt;/dev/dri/by-path&lt;/code&gt;, which are of the format
&lt;code&gt;&amp;lt;unique-id-for-card-&amp;gt;{card,render}&lt;/code&gt;&lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cgit.freedesktop.org/drm/libdrm/tree/xf86drm.c&#34;&gt;libdrm&amp;rsquo;s x86drm.c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dri.freedesktop.org/docs/drm/gpu/drm-uapi.html&#34;&gt;Linux&amp;rsquo;s DRM uAPI documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;A display controller is a hardware component that takes bitmaps and displays them.
It handles outputs, links, and modes. A GPU is a hardware component that receives
(3D) rendering commands and creates bitmaps based on these commands. It deals
with triangles, shaders, textures and pixels. In PCs, these two components
are usually colocated in a graphics card. The display controller may need
the bitmaps to be placed in a specialized on-card memory, and the GPU may produce
bitmaps in that specialized memory.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;The &lt;a href=&#34;https://cgit.freedesktop.org/drm/libdrm/&#34;&gt;libdrm&lt;/a&gt; library exists to
hide low-level details from applications. However, it is not a transparent
wrapper, so it is important to understand what it actually does and the
specific syscalls it makes.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Direct rendering manager, not digital rights management.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;DRI stands for &amp;ldquo;direct rendering interface&amp;rdquo;. Linux uses directory &lt;code&gt;/dev/dri&lt;/code&gt;
for historical reasons. FreeBSD has changed it to &lt;code&gt;/dev/drm&lt;/code&gt;.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;These devices used to also be exposed as &lt;code&gt;/proc/dri&lt;/code&gt;, but that is no longer the case.&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;There used to be a third type of device called &lt;code&gt;controlD&amp;lt;N&amp;gt;&lt;/code&gt;, but it was removed because
it did nothing.&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Kernel modesetting is a generic kernel API to configure display controllers,
contrasting with userland modesetting which involves userland poking hardware
directly for display controller configuration.&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;It&amp;rsquo;s &lt;code&gt;udev&lt;/code&gt; that creates these symlinks.&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;The matching of &lt;code&gt;card&amp;lt;N&amp;gt;&lt;/code&gt; and &lt;code&gt;renderD&amp;lt;N&amp;gt;&lt;/code&gt; devices used to be cumbersome because
their numbers do not correspond. The algorithm for matching was dependent on bus
type, with PCI/USB being matched by PCI/USB bus information, and platform devices
being matched using device tree information. This required searching for the necessary
information in &lt;code&gt;/sys/dev/char/&amp;lt;N&amp;gt;/device/subystem&lt;/code&gt;. All of this functionality is
is implemented in &lt;code&gt;libdrm&lt;/code&gt;.&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/00-de/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">DE/compositor development notes - introduction</title>
  <published>2023-07-05T00:00:00Z</published>
  <updated>2023-07-05T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/00-de/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;This blog post initiates a series on implementation of a &lt;a href=&#34;/new-de/&#34;&gt;new desktop environment&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The posts are not intended as comprehensvie documentation of the topics.
They serve as working notes for me to ensure my understanding of the topics.&lt;/p&gt;
&lt;p&gt;I limit the scope of the posts in the following ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I only describe Linux. I am not currently focused on portability.&lt;/li&gt;
&lt;li&gt;I only describe &lt;em&gt;modern&lt;/em&gt; Linux. Historical information is relegated to footnotes,
and I won&amp;rsquo;t delve into explaining how outdated interfaces function if they have
been completely replaced by modern ones.&lt;/li&gt;
&lt;li&gt;I only describe the desktop/laptop environment. The DE I am working on does not
attempt to support embedded, handhelds, and other environments.&lt;/li&gt;
&lt;li&gt;I focus on describing modern hardware. The primary platform for the DE is Apple M1/M2,
and the secondary platform is a modern PC with Intel graphics card. I won&amp;rsquo;t cover
big-endian processors, exotic buses, or compositing without a GPU.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The posts will be updated as I expand and correct them. I welcome corrections,
please send them to &lt;a href=&#34;mailto:dottedmag@dottedmag.net&#34;&gt;my e-mail&lt;/a&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;/blog/01-de-drm/&#34;&gt;Linux DRM devices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/02-de-vt/&#34;&gt;Linux VT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/03-de-drm-ioctl/&#34;&gt;DRM operations - capabilities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/04-de-drm-ioctl-2/&#34;&gt;DRM operations - resource sharing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/05-de-drm-pipeline/&#34;&gt;DRM pipeline&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

  
    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/dependencies/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">Dependencies</title>
  <published>2022-12-01T00:00:00Z</published>
  <updated>2022-12-01T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/dependencies/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;h2 id=&#34;why-dependencies-are-useful&#34;&gt;Why dependencies are useful?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Quick prototyping&lt;/li&gt;
&lt;li&gt;Bugs are someone else&amp;rsquo;s concern&lt;/li&gt;
&lt;li&gt;Reverse engineering is someone else&amp;rsquo;s concern&lt;/li&gt;
&lt;li&gt;Complicated algorithms and cryptography are someone else&amp;rsquo;s concern&lt;/li&gt;
&lt;li&gt;Security-critical code testing is someone else&amp;rsquo;s concern&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;why-dependencies-are-problematic&#34;&gt;Why dependencies are problematic?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Balooning build times&lt;/li&gt;
&lt;li&gt;Balooning build graph (hence tools slow down)&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s ideas of interfaces&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s ideas how to structure programs&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s ideas about build and code generation&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s bugs, and the authors of dependencies have their own priorities for bugfixing&lt;/li&gt;
&lt;li&gt;Someone else&amp;rsquo;s release and deprecation schedules&lt;/li&gt;
&lt;li&gt;Conflicts due to transitive dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;useful-dependencies&#34;&gt;Useful dependencies&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Algorithmics, such as cryptography and compression&lt;/li&gt;
&lt;li&gt;Stable interfaces for unstable external systems (scraping, unstable APIs etc)&lt;/li&gt;
&lt;li&gt;Parsing, including basic network protocols: JSON, HTTP, XML et al.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By and large, less often a dependency changes (without accumulating known bugs) the more potentially useful it is.&lt;/p&gt;
&lt;h2 id=&#34;harmful-dependencies&#34;&gt;Harmful dependencies&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Trivial wrappers around REST APIs&lt;/li&gt;
&lt;li&gt;Opinionated clients, libraries, helpers&lt;/li&gt;
&lt;li&gt;Abstractions over stable interfaces, especially unstable abstractions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;an-experience-of-dependectomy-in-a-medium-scale-go-project-300-kloc&#34;&gt;An experience of dependectomy in a medium-scale Go project (~300 kLOC)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Removing dependency does not make the code longer. Majority of removals made the code shorter.&lt;/li&gt;
&lt;li&gt;Build (especially link stage) becomes significantly faster.&lt;/li&gt;
&lt;li&gt;Linting becomes significantly faster.&lt;/li&gt;
&lt;li&gt;Non-REST protocols are painful but doable (small subset of Mongo protocol and Protobuf can be written in several
hours, though it&amp;rsquo;s definitely not production-grade. The project tries to avoid these protocols in production).&lt;/li&gt;
&lt;/ul&gt;

  
    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/new-de/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">New Linux desktop environment</title>
  <published>2021-12-26T00:00:00Z</published>
  <updated>2021-12-26T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/new-de/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;I am developing a new Linux desktop environment. This may sound odd in
2021, desktop environments being a part of Linux landscape for the last
20 years, so why I&amp;rsquo;m doing it?&lt;/p&gt;
&lt;p&gt;Obviously, I&amp;rsquo;m not satisfied with the available options (not only on Linux,
but also under macOS, but there is no chance to having better desktop environment
for macOS).&lt;/p&gt;
&lt;p&gt;More specifically, I do not see an existing solution that successfully
covers the following needs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;deep work,&lt;/li&gt;
&lt;li&gt;dynamic hardware and networking environment,&lt;/li&gt;
&lt;li&gt;hackability.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;deep-work&#34;&gt;Deep work&lt;/h2&gt;
&lt;p&gt;Deep work, or work in the state of the flow, requires environment that minimises
distractions and promotes formation of habits.&lt;/p&gt;
&lt;p&gt;Existing desktop environments are not scoring high on these counts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Visible latency of desktop environments is a constant source of distraction.
One can often &lt;em&gt;see&lt;/em&gt; the lag of GNOME desktop, even on a last-generation video
card! This means keystrokes and mouse clicks often get misdelivered or lost,
and this breaks the formation of habits: one can start forming a habit by
using keystrokes or mouse actions, only to see it crumbling when one becomes
good at this habit, as latency kicks in and breaks the flow.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application laggines creates unneeded source of distraction too. While desktop
environment may not do much in this regard, there is not enough work for
detection of laggy applications popping up their windows in the middle of
unrelated operation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stability. One might think that after 20 years of development desktop environments
finally settled down, but &lt;a href=&#34;https://gitlab.gnome.org/GNOME/gnome-shell/-/commit/7298ee23e91b756c7009b4d7687dfd8673856f8b&#34;&gt;this is not what happens&lt;/a&gt;.
Due to lack of hackability (see below), this makes upgrades very disruptive.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Notification systems are a nuisance, and desktop environments, while
acknowledging their distraction potential, and providing crude ways to disable
notifications, do not have a good solution for important, non-urgent
notifications.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dynamic-hardware-and-networking-environment&#34;&gt;Dynamic hardware and networking environment&lt;/h2&gt;
&lt;p&gt;Desktop environments are no longer used on PCs encased in tower cases sitting
on the floor with peripherals connected to them before boot. Hence the
desktop environment has to give user the control over the hardware and networks
coming and going dynamically, and the following is the &lt;em&gt;minimal&lt;/em&gt; list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WiFi connectivity&lt;/li&gt;
&lt;li&gt;Mobile broadband connectivity&lt;/li&gt;
&lt;li&gt;VPNs&lt;/li&gt;
&lt;li&gt;Bluetooth input and output (keyboards, mices, trackpads, audio)&lt;/li&gt;
&lt;li&gt;USB peripheral devices (mass storage, eGPUs)&lt;/li&gt;
&lt;li&gt;Displays (HDMI, DisplayPort, Thunderbolt, DB-over-USB tunneling)&lt;/li&gt;
&lt;li&gt;Thunderbolt access control&lt;/li&gt;
&lt;li&gt;Various weird stuff, like pairing Logitech mice and keyboards using
their special dongles.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This rules out any Wayland compositors except KDE and GNOME: like X11 window
managers, many niche Wayland compositors are scoring high in the &amp;ldquo;deep work&amp;rdquo;
department, but they do not provide the user with any tools for hardware
management.&lt;/p&gt;
&lt;p&gt;As a side-note, wlroots-enabled compositors are doubly disqualified
&lt;a href=&#34;https://github.com/danvd/wlroots-eglstreams&#34;&gt;as wlroots project won&amp;rsquo;t merge support for NVidia drivers due to political reasons&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;hackability&#34;&gt;Hackability&lt;/h2&gt;
&lt;p&gt;If the software was perfect, hackability won&amp;rsquo;t be needed. Alas it is not, so
to overcome the imperfections of software we still have to improve it.&lt;/p&gt;
&lt;p&gt;Hackability is a freedom often touted by open source advocates, but this
freedom is very hard to exercise in reality for existing desktop
environments.&lt;/p&gt;
&lt;p&gt;Imagine a single person trying to change a way GNOME shell works. How does one
learn how to do it, how does one prepare, how does one execute the change, and
how does one integrate this change?&lt;/p&gt;
&lt;p&gt;Direct dependencies of &lt;code&gt;gnome-shell&lt;/code&gt; package in Debian include 64 packages,
including JavaScript and Python interpreters. The whole list of obviously
GNOME-related indirect dependencies is over a hundred packages long.&lt;/p&gt;
&lt;p&gt;How does one understand which piece of code to change? By wading around in the
source code that contains tons of boilerplate?&lt;/p&gt;
&lt;p&gt;How does one create a debug environment for experimenting with GNOME shell?
GNOME shell contains a lot of C code, so all the libraries have to be rebuilt in
debug mode. I don&amp;rsquo;t see a documentation how to do it in a way that does not
ruin the system one is developing on. NixOS comes close, and actually provides
a way to integrate changes back to the running system, but
&lt;a href=&#34;/2021/10/18/linux-is-not-os&#34;&gt;it comes with its own set of drawbacks&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once this is done, how one uses the changed code, especially if the fix is not
in the shell itself (as a leaf package it could easily be replaced), but in a
library? What if the change is spread over several packages?&lt;/p&gt;
&lt;p&gt;Hackability can&amp;rsquo;t be introduced into a large system once it&amp;rsquo;s built, so
there is no hope it can be added to existing desktop environments.&lt;/p&gt;
&lt;h2 id=&#34;project&#34;&gt;Project&lt;/h2&gt;
&lt;p&gt;The project is named &lt;a href=&#34;https://github.com/5de&#34;&gt;5DE&lt;/a&gt;, and the goals for the project
are as stated above: try to make a Linux desktop environment that facilitates
deep work, handles dynamic hardware/networking environment of computers and
provides hackability.&lt;/p&gt;
&lt;p&gt;There is not much there yet, and I will be documenting its progress in this blog
for the time being.&lt;/p&gt;

  
    
  </content>
</entry>

<entry>
  <id>https://dottedmag.net/blog/linux-is-not-os/</id>
  <author><name>Mikhail Gusarov</name></author>
  <title type="html">Linux is not OS</title>
  <published>2021-10-18T00:00:00Z</published>
  <updated>2021-10-18T00:00:00Z</updated>
  
  <link href="https://dottedmag.net/blog/linux-is-not-os/" rel="alternate"></link>
  <content type="html">
    
      
  &lt;p&gt;TL;DR: Every Linux distribution is a separate OS. Niche Linux distributions will
never enjoy even the modest application selection available for mainstream Linux
distributions.&lt;/p&gt;
&lt;h2 id=&#34;operating-systems-and-why-they-matter&#34;&gt;Operating systems and why they matter&lt;/h2&gt;
&lt;p&gt;Operating system is software that sits directly atop computer hardware, and performs multiple functions, namely&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sharing resources between applications,&lt;/li&gt;
&lt;li&gt;isolating applications from each other,&lt;/li&gt;
&lt;li&gt;providing applications with a stable interface to access the hardware.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Operating systems by themselves are useless, they exist solely to enable
applications to be run.&lt;/p&gt;
&lt;p&gt;Stable interface is the crucial invention that enables applications: without it
every application would have to be ported to every combination of hardware in
existence, an untenable task&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2 id=&#34;linux-distributions-are-operating-systems&#34;&gt;Linux distributions are operating systems&lt;/h2&gt;
&lt;p&gt;Operating system is defined by its interface: syscalls, file layout, packages
and package managers, services and libraries, function call ABI etc.&lt;/p&gt;
&lt;p&gt;Linux and GNU projects do not produce operating systems. Both projects produce
source code, one for the kernel, another for userspace components.&lt;/p&gt;
&lt;p&gt;Every Linux distribution takes the source code produced by Linux, GNU and other
projects, and combines them into an operating system, deciding on syscall
interface, file layout, available libraries and other aspects that together
specify the operating system interface.&lt;/p&gt;
&lt;p&gt;Different distributions make different choices, and therefore they are closely
related operating systems, but not a single OS. Even Linux syscall interface
subtly changes from distribution to distribution, as they pick and choose
options to build their kernels.&lt;/p&gt;
&lt;p&gt;In practice this means that application developers are unable to target &amp;ldquo;Linux&amp;rdquo;,
they have to target many Linux distributions. This is most evident when clicking
&amp;ldquo;Download&amp;rdquo; button that opens a menu with the set of packages to choose from, but
even if the package for a particular package manager is available, the installed
application may not work if it was not tested on this particular distribution.&lt;/p&gt;
&lt;h2 id=&#34;consequences-for-niche-linux-distributions&#34;&gt;Consequences for niche Linux distributions&lt;/h2&gt;
&lt;p&gt;Every niche Linux distribution that does not follow the interface of a larger
one is a unique OS, closely related but not compatible with other Linux OSes.
This means the applications have to be ported.&lt;/p&gt;
&lt;p&gt;Application developers have to choose what targets their applications support.
With Linux distributions being just a blip on the graph of operating systems
popularity, the application developers may not invest significant amount of
resources into porting and testing.&lt;/p&gt;
&lt;p&gt;Even this blip is hopelessly fragmented: there are hundreds of Linux
distributions. Therefore the only realistic option for application developers is
to care about several largest distributions, if they care about Linux at all.&lt;/p&gt;
&lt;p&gt;This places the burden of porting and testing on the niche distribution makers,
which means that the only most popular and easily ported applications will be
available.&lt;/p&gt;
&lt;h2 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;h3 id=&#34;arent-snap-and-flatpak-designed-to-run-applications-on-any-linux-distribution&#34;&gt;Aren&amp;rsquo;t Snap and Flatpak designed to run applications on any Linux distribution?&lt;/h3&gt;
&lt;p&gt;This is true. Snap and Flatpak can be seen as virtualized operating systems.&lt;/p&gt;
&lt;p&gt;Some underlying variations still leak through the abstraction (e.g. the set of
supported Linux syscalls may vary based on distribution&amp;rsquo;s kernel configuration),
but the resulting ABI is way stabler than the native one.&lt;/p&gt;
&lt;p&gt;This is the easiest way to target Linux for applications that do not need
services beyond what Snap and Flatpak provide.&lt;/p&gt;
&lt;h3 id=&#34;shouldnt-application-authors-stick-to-the-published-api-and-let-distribution-authors-build-and-package-their-software&#34;&gt;Shouldn&amp;rsquo;t application authors stick to the published API, and let distribution authors build and package their software?&lt;/h3&gt;
&lt;p&gt;This is totally fine. However note that this means application authors merely
supply more raw ingredients, and distribution authors have to make/port
applications for their OS out of these ingredients&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h3 id=&#34;shouldnt-application-authors-stick-to-the-standards-to-make-porting-trivial&#34;&gt;Shouldn&amp;rsquo;t application authors stick to the standards to make porting trivial?&lt;/h3&gt;
&lt;p&gt;It does not work.&lt;/p&gt;
&lt;p&gt;First, there aren&amp;rsquo;t many great standards out there to stick to. LSB is outdated.
SUSv4 only covers basic syscalls and shell. X11 and Wayland are low-level, and
contain numerous extensions.&lt;/p&gt;
&lt;p&gt;Second, existing standards cover a small subset of functionality provided by
Linux and userspace libraries. Standards do not cover &lt;code&gt;signalfd(2)&lt;/code&gt; or GTK4.&lt;/p&gt;
&lt;p&gt;Third, even if porting is made relatively trivial, there is additional per-OS
work of testing the application. Application authors have at least be aware of
existence of a particular niche distribution to be able to test and release
their application, and with distributions counting in hundreds this is not
feasible.&lt;/p&gt;
&lt;h3 id=&#34;i-dont-care-about-anything-thats-not-packaged-by-the-distribution&#34;&gt;I don&amp;rsquo;t care about anything that&amp;rsquo;s not packaged by the distribution&lt;/h3&gt;
&lt;p&gt;This is totally fine. Just note that you are using a niche OS with a limited set
of applications available.&lt;/p&gt;
&lt;h2 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Some small platforms (ZX Spectrum, C64) could get away with it for a while by having a stable set of hardware, however this approach does not work long-term, due to sheer number of computer components and periphery produced.
Manufacturers of these platforms got bitten by the hardware stability when they introduced new versions of their computers.
Application developers were disincentivised to use new features because they also had to target large install base of older computers, so new computers didn&amp;rsquo;t provide any benefits to the end users due to lack of applications, and both Sinclair and Commodore ultimately closed down.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Moreover, a free software license is not a universally sound choice for software authors. This limits the set of applications available for the distributions that insist that the application packaging and testing has to be done by the distribution maintainers.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    
  </content>
</entry>


</feed>
